// Scalable Translation System
class ScalableTranslator {
    constructor() {
        this.currentLanguage = 'en';
        this.translatedContent = null;
        this.originalContent = null;
        this.translationCache = new Map();
        this.init();
    }

    async init() {
        // Load saved language preference
        this.currentLanguage = localStorage.getItem('cookbook-language') || 'en';
        
        // Load original content
        await this.loadOriginalContent();
        
        // Set default content to English
        this.translatedContent = this.originalContent;
        
        // Translate content if needed
        if (this.currentLanguage !== 'en') {
            await this.translateContent();
            // If translation failed, translatedContent is already set to originalContent
        }
    }

    async loadOriginalContent() {
        try {
            const response = await fetch('data/cookbook-data.json');
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            this.originalContent = await response.json();
        } catch (error) {
            console.error('Failed to load original content:', error);
            // Create a fallback content structure
            this.originalContent = {
                ui: {
                    title: "My Recipe Journal",
                    search_placeholder: "Search recipes...",
                    categories: {
                        all: "All Recipes",
                        main_courses: "Main Courses",
                        desserts: "Desserts",
                        soups: "Soups"
                    },
                    dietary_filters: {
                        vegan: "Vegan",
                        gluten_free: "Gluten Free"
                    }
                },
                navigation: {
                    home: "Home",
                    breadcrumbs: {
                        separator: "â€º"
                    }
                },
                categories: {
                    "main-courses": {
                        name: "Main Courses",
                        recipes: [
                            { id: "bourguignon", title: "Seitan Bourguignon", file: "bourguignon.html", image: "bourguignon.webp", description: "A hearty vegetarian version of the classic French dish" },
                            { id: "lentils_soup", title: "Lentils Soup", file: "lentils_soup.html", image: "lentils_soup.webp", description: "Warm and nutritious lentil soup" },
                            { id: "moussaka", title: "Moussaka", file: "moussaka.html", image: "moussaka.webp", description: "Layered eggplant and potato casserole" }
                        ]
                    },
                    desserts: {
                        name: "Desserts",
                        recipes: [
                            { id: "banana_bread", title: "Banana Bread", file: "banana_bread.html", image: "banana_bread.webp", description: "Moist and delicious banana bread" },
                            { id: "chocolate_truffles", title: "Chocolate Truffles", file: "chocolate_truffles.html", image: "chocolate_truffles.webp", description: "Rich and creamy chocolate truffles" },
                            { id: "rice_pudding", title: "Rice Pudding", file: "rice_pudding.html", image: "rice_pudding.webp", description: "Creamy and comforting rice pudding" }
                        ]
                    }
                }
            };
        }
    }

    async translateContent() {
        if (!this.originalContent) {
            console.error('No original content to translate');
            return;
        }

        try {
            // Check cache first
            const cacheKey = `translation_${this.currentLanguage}`;
            const cachedTranslation = this.translationCache.get(cacheKey);
            
            if (cachedTranslation) {
                this.translatedContent = cachedTranslation;
                return;
            }

            // Flatten the content object for translation
            const flatContent = this.flattenObject(this.originalContent);
            
            // Extract all text values for translation
            const textToTranslate = Object.values(flatContent).filter(value => 
                typeof value === 'string' && value.trim().length > 0
            );

            if (textToTranslate.length === 0) {
                this.translatedContent = this.originalContent;
                return;
            }

            // Translate texts
            const translatedTexts = await this.translateTexts(textToTranslate);
            
            if (translatedTexts && translatedTexts.length > 0) {
                // Reconstruct the translated content
                this.translatedContent = this.reconstructTranslatedContent(flatContent, translatedTexts);
                
                // Cache the translation
                this.translationCache.set(cacheKey, this.translatedContent);
            } else {
                // Translation failed, use original content
                this.translatedContent = this.originalContent;
            }
        } catch (error) {
            console.error('Translation failed:', error);
            this.translatedContent = this.originalContent;
        }
    }

    flattenObject(obj, prefix = '') {
        const flattened = {};
        
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const newKey = prefix ? `${prefix}.${key}` : key;
                
                if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
                    Object.assign(flattened, this.flattenObject(obj[key], newKey));
                } else {
                    flattened[newKey] = obj[key];
                }
            }
        }
        
        return flattened;
    }

    async translateTexts(texts) {
        try {
            const response = await fetch('https://api.mymemory.translated.net/get', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    q: texts.join('\n'),
                    langpair: `en|${this.currentLanguage}`
                })
            });

            if (!response.ok) {
                throw new Error(`Translation API error: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.responseStatus === 200 && data.responseData) {
                return data.responseData.translatedText.split('\n');
            } else {
                throw new Error('Translation API returned invalid response');
            }
        } catch (error) {
            console.error('Translation API error:', error);
            return null;
        }
    }

    reconstructTranslatedContent(flatContent, translatedTexts) {
        const translatedFlatContent = { ...flatContent };
        const originalValues = Object.values(flatContent);
        
        translatedTexts.forEach((translatedText, index) => {
            const originalValue = originalValues[index];
            const key = Object.keys(flatContent).find(k => flatContent[k] === originalValue);
            if (key) {
                translatedFlatContent[key] = translatedText;
            }
        });
        
        return this.unflattenObject(translatedFlatContent);
    }

    unflattenObject(flatObj) {
        const result = {};
        
        for (const key in flatObj) {
            if (flatObj.hasOwnProperty(key)) {
                const keys = key.split('.');
                let current = result;
                
                for (let i = 0; i < keys.length - 1; i++) {
                    const k = keys[i];
                    if (!current[k]) {
                        current[k] = {};
                    }
                    current = current[k];
                }
                
                current[keys[keys.length - 1]] = flatObj[key];
            }
        }
        
        return result;
    }

    async changeLanguage(newLang) {
        if (newLang === this.currentLanguage) return;
        
        this.currentLanguage = newLang;
        localStorage.setItem('cookbook-language', newLang);
        
        if (newLang === 'en') {
            this.translatedContent = this.originalContent;
        } else {
            await this.translateContent();
        }
        
        this.updatePageContent();
    }

    updatePageContent() {
        this.updateUIElements();
        this.updateRecipeContent();
    }

    updateUIElements() {
        // Update page title
        const titleElement = document.querySelector('title');
        if (titleElement) {
            titleElement.textContent = this.getText('ui.title');
        }

        // Update header title
        const headerTitle = document.querySelector('#branding h1');
        if (headerTitle) {
            headerTitle.textContent = this.getText('ui.title');
        }

        // Update search placeholder
        const searchInput = document.querySelector('#search-bar');
        if (searchInput) {
            searchInput.placeholder = this.getText('ui.search_placeholder');
        }

        // Update filter buttons
        const filterButtons = document.querySelectorAll('.filter-btn');
        filterButtons.forEach(button => {
            const category = button.getAttribute('data-category');
            const dietary = button.getAttribute('data-dietary');
            
            if (category) {
                const translatedText = this.getText(`ui.categories.${category}`);
                if (translatedText) button.textContent = translatedText;
            }
            
            if (dietary) {
                const translatedText = this.getText(`ui.dietary_filters.${dietary}`);
                if (translatedText) button.textContent = translatedText;
            }
        });
    }

    updateRecipeContent() {
        // Update recipe titles in recipe loader
        if (window.recipeLoader) {
            const translatedCategories = {};
            
            // Group recipes by category
            if (this.translatedContent.categories) {
                Object.keys(this.translatedContent.categories).forEach(categoryKey => {
                    const category = this.translatedContent.categories[categoryKey];
                    if (category && category.recipes) {
                        translatedCategories[categoryKey] = {
                            recipes: category.recipes
                        };
                    }
                });
            }
            
            window.recipeLoader.updateWithTranslatedContent(translatedCategories);
        }
    }

    getText(keyPath) {
        const keys = keyPath.split('.');
        let value = this.translatedContent;
        
        for (const key of keys) {
            if (value && typeof value === 'object' && key in value) {
                value = value[key];
            } else {
                return null;
            }
        }
        
        return typeof value === 'string' ? value : null;
    }
}

// Initialize scalable translator
window.scalableTranslator = new ScalableTranslator(); 